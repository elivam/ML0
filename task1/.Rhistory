# Q - число ошибок
Q <- 0
#пока число ошибок на выборке не окажется достаточно мало
#у меня достаточно мало это 10
i <- 1
h <- 0.4
while(Q < 3){
z<-c(xl[i,1],xl[i,2])
class <- potential(xl,z,gamma[i],h)
if(class != xl[i,3]){
gamma[i]<-gamma[i]+1
Q <- Q + 1
}
i <- i + 1
}
return (gamma)
}
gam <- gamma(iris[sample(1:150,30), 3:4])
colors <- c("setosa" = "#FFCC33", "versicolor" = "#0033FF",
"virginica" = "#CC00CC", "no-Class" = "#CCCCFF")
evcliDestance<- function(u, v){
sqrt(sum((u - v)^2))
}
# Треугольное
triang_kernel <- function(r) {
if (abs(r) > 1)
{
return (0)
}
return (1 - abs(r))
}
# Гауссовское
gauss_kernel <- function(r)
{
(2*pi)^0.5 * exp(-0.5 * r*r)
}
sortObjByDist <- function(xl, z, metricFunction =evcliDestance){
l <- dim(xl)[1]
n <- dim(xl)[2] - 1
distances <- matrix(NA, l, 2)
for (i in 1:l)
{
distances[i, ] <- c(i, metricFunction(xl[i, 1:n], z))
}
return (distances);
}
potential <- function(xl, z, gamma, h) {
l <- dim(xl)[1]
n <- dim(xl)[2] - 1
orderedXl <- sortObjByDist(xl, z)
#classes <- orderedXl[1:l, n]
m <- orderedXl[1:l, n]
classes <- xl[1:l, n + 1]
for(i in 1:l)
{
w <- gamma[i] * gauss_kernel(orderedXl[i,2]/h)
m[classes[i]] <-  m[classes[i]] + w
}
if(sum(m) != 0) {
class <- names(which.max(m))
} else {
class <- "no-Class"
}
return(class)
}
gamma <-function (xl){
l <- dim(xl)[1]
gamma <- rep(0,l)
# Q - число ошибок
Q <- 0
#пока число ошибок на выборке не окажется достаточно мало
#у меня достаточно мало это 10
i <- 1
h <- 0.4
while(Q < 3){
z<-c(xl[i,1],xl[i,2])
class <- potential(xl,z,gamma[i],h)
if(class != xl[i,3]){
gamma[i]<-gamma[i]+1
Q <- Q + 1
}
i <- i + 1
}
return (gamma)
}
gam <- gamma(iris[sample(1:150,30), 3:4])
colors <- c("setosa" = "#FFCC33", "versicolor" = "#0033FF",
"virginica" = "#CC00CC", "no-Class" = "#CCCCFF")
plot(iris[, 3:4], pch = 20, bg = colors[iris$Species], col = colors[iris$Species], asp = 1)
z <- c(1,1)
evcliDestance<- function(u, v){
sqrt(sum((u - v)^2))
}
# Треугольное
triang_kernel <- function(r) {
if (abs(r) > 1)
{
return (0)
}
return (1 - abs(r))
}
# Гауссовское
gauss_kernel <- function(r)
{
(2*pi)^0.5 * exp(-0.5 * r*r)
}
sortObjByDist <- function(xl, z, metricFunction =evcliDestance){
l <- dim(xl)[1]
n <- dim(xl)[2] - 1
distances <- matrix(NA, l, 2)
for (i in 1:l)
{
distances[i, ] <- c(i, metricFunction(xl[i, 1:n], z))
}
return (distances);
}
potential <- function(xl, z, gamma, h) {
l <- dim(xl)[1]
n <- dim(xl)[2] - 1
orderedXl <- sortObjByDist(xl, z)
#classes <- orderedXl[1:l, n]
m <- orderedXl[1:l, n]
classes <- xl[1:l, n + 1]
for(i in 1:l)
{
w <- gamma[i] * gauss_kernel(orderedXl[i,2]/h)
m[classes[i]] <-  m[classes[i]] + w
}
#if(sum(m) != 0) {
class <- names(which.max(m))
#} else {
# class <- "no-Class"
#}
return(class)
}
gamma <-function (xl){
l <- dim(xl)[1]
gamma <- rep(0,l)
# Q - число ошибок
Q <- 0
#пока число ошибок на выборке не окажется достаточно мало
#у меня достаточно мало это 10
i <- 1
h <- 0.4
while(Q < 3){
z<-c(xl[i,1],xl[i,2])
class <- potential(xl,z,gamma[i],h)
if(class != xl[i,3]){
gamma[i]<-gamma[i]+1
Q <- Q + 1
}
i <- i + 1
}
return (gamma)
}
gam <- gamma(iris[sample(1:150,30), 3:4])
colors <- c("setosa" = "#FFCC33", "versicolor" = "#0033FF",
"virginica" = "#CC00CC", "no-Class" = "#CCCCFF")
orderedXl <- sortObjByDist(iris[sample(1:150,30),3:4], c(1,1.5))
m <- orderedXl[1:l, n]
m <- orderedXl[1:30, n]
m <- orderedXl[1:30, dim(iris[sample(1:150,30))[2] - 1]
m <- orderedXl[1:30, dim(iris[sample(1:150,30))[2] - 1])
m <- orderedXl[1:30, dim(iris[sample(1:150,30)[2] - 1])
sortObjByDist(xl, z)
sortObjByDist(iris[sample(1:150,30), 3:5], c(1,1.3))
evcliDestance<- function(u, v){
sqrt(sum((u - v)^2))
}
# Треугольное
triang_kernel <- function(r) {
if (abs(r) > 1)
{
return (0)
}
return (1 - abs(r))
}
# Гауссовское
gauss_kernel <- function(r)
{
(2*pi)^0.5 * exp(-0.5 * r*r)
}
sortObjByDist <- function(xl, z, metricFunction =evcliDestance){
l <- dim(xl)[1]
n <- dim(xl)[2] - 1
distances <- matrix(NA, l, 2)
for (i in 1:l)
{
distances[i, ] <- c(i, metricFunction(xl[i, 1:n], z))
}
return (distances);
}
potential <- function(xl, z, gamma, h) {
l <- dim(xl)[1]
n <- dim(xl)[2] - 1
distances <- sortObjectsByDist(xl, z)
m <- c("setosa" = 0, "versicolor" = 0, "virginica" = 0)
classes <- xl[1:l, n + 1]
for(i in 1:l)
{
w<-gamma[i]*c4(distances[i,2]/h)
m[classes[i]]<-m[classes[i]]+w
}
if(m[1]!=0 || m[2]!=0 || m[3]!=0)class <- names(which.max(m))
else class<-"not_class"
if(class==0)class<-"grey"
return (class)
}
gamma <-function (xl){
l <- dim(xl)[1]
gamma <- rep(0,l)
# Q - число ошибок
Q <- 0
#пока число ошибок на выборке не окажется достаточно мало
#у меня достаточно мало это 10
i <- 1
h <- 0.4
while(Q < 3){
z<-c(xl[i,1],xl[i,2])
class <- potential(xl,z,gamma[i],h)
if(class != xl[i,3]){
gamma[i]<-gamma[i]+1
Q <- Q + 1
}
i <- i + 1
}
return (gamma)
}
gam <- gamma(iris[sample(1:150,30), 3:4])
colors <- c("setosa" = "#FFCC33", "versicolor" = "#0033FF",
"virginica" = "#CC00CC", "no-Class" = "#CCCCFF")
plot(iris[, 3:4], pch = 20, bg = colors[iris$Species], col = colors[iris$Species], asp = 1)
z <- c(1,1)
class <- potential(iris[sample(1:150,30), 3:5], z,gam, 0.4)
points(z[1], z[2], pch = 21, bg = colors[class], asp = 1)
evcliDestance<- function(u, v){
sqrt(sum((u - v)^2))
}
# Треугольное
triang_kernel <- function(r) {
if (abs(r) > 1)
{
return (0)
}
return (1 - abs(r))
}
# Гауссовское
gauss_kernel <- function(r)
{
(2*pi)^0.5 * exp(-0.5 * r*r)
}
sortObjByDist <- function(xl, z, metricFunction =evcliDestance){
l <- dim(xl)[1]
n <- dim(xl)[2] - 1
distances <- matrix(NA, l, 2)
for (i in 1:l)
{
distances[i, ] <- c(i, metricFunction(xl[i, 1:n], z))
}
return (distances);
}
potential <- function(xl, z, gamma, h) {
l <- dim(xl)[1]
n <- dim(xl)[2] - 1
distances <- sortObjectsByDist(xl, z)
m <- c("setosa" = 0, "versicolor" = 0, "virginica" = 0)
classes <- xl[1:l, n + 1]
for(i in 1:l)
{
w<-gamma[i]*c4(distances[i,2]/h)
m[classes[i]]<-m[classes[i]]+w
}
if(m[1]!=0 || m[2]!=0 || m[3]!=0)class <- names(which.max(m))
else class<-"not_class"
if(class==0)class<-"grey"
return (class)
}
gamma <-function (xl){
l <- dim(xl)[1]
gamma <- rep(0,l)
# Q - число ошибок
Q <- 0
#пока число ошибок на выборке не окажется достаточно мало
#у меня достаточно мало это 10
i <- 1
h <- 0.4
while(Q < 3){
z<-c(xl[i,1],xl[i,2])
class <- potential(xl,z,gamma[i],h)
if(class != xl[i,3]){
gamma[i]<-gamma[i]+1
Q <- Q + 1
}
i <- i + 1
}
return (gamma)
}
gam <- gamma(iris[sample(1:150,30), 3:4])
colors <- c("setosa" = "#FFCC33", "versicolor" = "#0033FF",
"virginica" = "#CC00CC", "no-Class" = "#CCCCFF")
plot(iris[, 3:4], pch = 20, bg = colors[iris$Species], col = colors[iris$Species], asp = 1)
z <- c(2,1)
class <- potential(iris[sample(1:150,30), 3:5], z,gam, 0.4)
points(z[1], z[2], pch = 21, bg = colors[class], asp = 1)
evcliDestance<- function(u, v){
sqrt(sum((u - v)^2))
}
# Треугольное
triang_kernel <- function(r) {
if (abs(r) > 1)
{
return (0)
}
return (1 - abs(r))
}
# Гауссовское
gauss_kernel <- function(r)
{
(2*pi)^0.5 * exp(-0.5 * r*r)
}
sortObjByDist <- function(xl, z, metricFunction =evcliDestance){
l <- dim(xl)[1]
n <- dim(xl)[2] - 1
distances <- matrix(NA, l, 2)
for (i in 1:l)
{
distances[i, ] <- c(i, metricFunction(xl[i, 1:n], z))
}
return (distances);
}
potential <- function(xl, z, gamma, h) {
l <- dim(xl)[1]
n <- dim(xl)[2] - 1
distances <- sortObjectsByDist(xl, z)
m <- c("setosa" = 0, "versicolor" = 0, "virginica" = 0)
classes <- xl[1:l, n + 1]
for(i in 1:l)
{
w<-gamma[i]*c4(distances[i,2]/h)
m[classes[i]]<-m[classes[i]]+w
}
if(m[1]!=0 || m[2]!=0 || m[3]!=0)class <- names(which.max(m))
else class<-"not_class"
if(class==0)class<-"grey"
return (class)
}
gamma <-function (xl){
l <- dim(xl)[1]
gamma <- rep(0,l)
# Q - число ошибок
Q <- 0
#пока число ошибок на выборке не окажется достаточно мало
#у меня достаточно мало это 10
i <- 1
h <- 0.4
while(Q < 5){
z<-c(xl[i,1],xl[i,2])
class <- potential(xl,z,gamma[i],h)
if(class != xl[i,3]){
gamma[i]<-gamma[i]+1
Q <- Q + 1
}
i <- i + 1
}
return (gamma)
}
gam <- gamma(iris[sample(1:150,30), 3:4])
colors <- c("setosa" = "#FFCC33", "versicolor" = "#0033FF",
"virginica" = "#CC00CC", "no-Class" = "#CCCCFF")
plot(iris[, 3:4], pch = 20, bg = colors[iris$Species], col = colors[iris$Species], asp = 1)
z <- c(2,1)
class <- potential(iris[sample(1:150,30), 3:5], z,gam, 0.4)
points(z[1], z[2], pch = 21, bg = colors[class], asp = 1)
evcliDestance<- function(u, v){
sqrt(sum((u - v)^2))
}
# Треугольное
triang_kernel <- function(r) {
if (abs(r) > 1)
{
return (0)
}
return (1 - abs(r))
}
# Гауссовское
gauss_kernel <- function(r)
{
(2*pi)^0.5 * exp(-0.5 * r*r)
}
sortObjByDist <- function(xl, z, metricFunction =evcliDestance){
l <- dim(xl)[1]
n <- dim(xl)[2] - 1
distances <- matrix(NA, l, 2)
for (i in 1:l)
{
distances[i, ] <- c(i, metricFunction(xl[i, 1:n], z))
}
return (distances);
}
potential <- function(xl, z, gamma, h) {
l <- dim(xl)[1]
n <- dim(xl)[2] - 1
distances <- sortObjectsByDist(xl, z)
m <- c("setosa" = 0, "versicolor" = 0, "virginica" = 0)
classes <- xl[1:l, n + 1]
for(i in 1:l)
{
w<-gamma[i]*c4(distances[i,2]/h)
m[classes[i]]<-m[classes[i]]+w
}
if(m[1]!=0 || m[2]!=0 || m[3]!=0)class <- names(which.max(m))
else class<-"not_class"
if(class==0)class<-"grey"
return (class)
}
gamma <-function (xl){
l <- dim(xl)[1]
gamma <- rep(0,l)
# Q - число ошибок
Q <- 0
#пока число ошибок на выборке не окажется достаточно мало
#у меня достаточно мало это 10
i <- 1
h <- 0.4
while(Q < 5){
z<-c(xl[i,1],xl[i,2])
class <- potential(xl,z,gamma[i],h)
if(class != xl[i,3]){
gamma[i]<-gamma[i]+1
Q <- Q + 1
}
i <- i + 1
}
return (gamma)
}
gam <- gamma(iris[sample(1:150,30), 3:4])
colors <- c("setosa" = "#FFCC33", "versicolor" = "#0033FF",
"virginica" = "#CC00CC", "no-Class" = "#CCCCFF")
xl <- iris[sample(1:150,30),3:4]
plot(xl, pch = 20, bg = colors[iris$Species], col = colors[iris$Species], asp = 1)
z <- c(2,1)
class <- potential(xl, z,gam, 0.4)
points(z[1], z[2], pch = 21, bg = colors[class], asp = 1)
evcliDestance<- function(u, v){
sqrt(sum((u - v)^2))
}
# Треугольное
triang_kernel <- function(r) {
if (abs(r) > 1)
{
return (0)
}
return (1 - abs(r))
}
# Гауссовское
gauss_kernel <- function(r)
{
(2*pi)^0.5 * exp(-0.5 * r*r)
}
sortObjByDist <- function(xl, z, metricFunction =evcliDestance){
l <- dim(xl)[1]
n <- dim(xl)[2] - 1
distances <- matrix(NA, l, 2)
for (i in 1:l)
{
distances[i, ] <- c(i, metricFunction(xl[i, 1:n], z))
}
return (distances);
}
potential <- function(xl, z, gamma, h) {
l <- dim(xl)[1]
n <- dim(xl)[2] - 1
distances <- sortObjectsByDist(xl, z)
m <- c("setosa" = 0, "versicolor" = 0, "virginica" = 0)
classes <- xl[1:l, n + 1]
for(i in 1:l)
{
w<-gamma[i]*c4(distances[i,2]/h)
m[classes[i]]<-m[classes[i]]+w
}
if(m[1]!=0 || m[2]!=0 || m[3]!=0)class <- names(which.max(m))
else class<-"not_class"
if(class==0)class<-"grey"
return (class)
}
gamma <-function (xl){
l <- dim(xl)[1]
gamma <- rep(0,l)
# Q - число ошибок
Q <- 0
#пока число ошибок на выборке не окажется достаточно мало
#у меня достаточно мало это 10
i <- 1
h <- 0.4
while(Q < 5){
z<-c(xl[i,1],xl[i,2])
class <- potential(xl,z,gamma[i],h)
if(class != xl[i,3]){
gamma[i]<-gamma[i]+1
Q <- Q + 1
}
i <- i + 1
}
return (gamma)
}
gam <- gamma(iris[sample(1:150,30), 3:4])
colors <- c("setosa" = "#FFCC33", "versicolor" = "#0033FF",
"virginica" = "#CC00CC", "no-Class" = "#CCCCFF")
plot(iris[, 3:4], pch = 20, bg = colors[iris$Species], col = colors[iris$Species], asp = 1)
z <- c(4,1)
class <- potential(iris[sample(1:150,30), 3:5], z,gam, 0.4)
points(z[1], z[2], pch = 21, bg = colors[class], asp = 1)
